use flume::{Receiver, Sender};
use log::{info, warn};
use tokio::select;

use super::Payload;
use crate::base::actions::Cancellation;
use crate::uplink_config::UplinkConfig;
use crate::{Action, ActionResponse};
use std::fmt::{Display, Formatter};
use std::{collections::HashMap, fmt::Debug};
use std::sync::Arc;

#[derive(Debug)]
pub enum Error {
    DuplicateActionRoutes { action_name: String },
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Debug::fmt(self, f)
    }
}

impl std::error::Error for Error {}

pub struct ActionsBridge {
    /// Full configuration
    config: Arc<UplinkConfig>,
    /// Actions incoming from backend
    actions_rx: Receiver<Action>,
    /// for sending action responses
    messages_tx: Sender<Payload>,
    /// Apps registered with the bridge
    /// NOTE: Sometimes action_routes could overlap, the latest route
    /// to be registered will be used in such a circumstance.
    action_routes: HashMap<String, Sender<Action>>,
}

impl ActionsBridge {
    pub fn new(
        config: Arc<UplinkConfig>,
        actions_rx: Receiver<Action>,
        messages_tx: Sender<Payload>,
    ) -> Self {
        Self {
            config,
            actions_rx,
            messages_tx,
            action_routes: HashMap::with_capacity(16),
        }
    }

    pub fn register_action_route(
        &mut self,
        action_name: String,
        actions_tx: Sender<Action>,
    ) -> Result<(), Error> {
        if self.action_routes.insert(action_name.clone(), actions_tx).is_some() {
            return Err(Error::DuplicateActionRoutes { action_name });
        }
        Ok(())
    }

    pub fn register_action_routes(
        &mut self,
        routes: Vec<String>,
        actions_tx: Sender<Action>,
    ) -> Result<(), Error> {
        for route in routes {
            self.register_action_route(route, actions_tx.clone())?;
        }
        Ok(())
    }

    pub async fn start(&mut self) {
        loop {
            select! {
                result = self.actions_rx.recv_async() => {
                    match result {
                        Ok(action) => {
                            // Reactlabs setup processes logs generated by uplink
                            info!("Received action: {:?}", action);
                            // TODO: should this be removed
                            let _ = self.messages_tx.send_async(
                                ActionResponse::progress(action.action_id.as_str(), "Received", 0).to_payload()
                            ).await;
                            self.handle_incoming_action(action).await;
                        }
                        Err(_) => {
                            warn!("stopping action routing task");
                            return;
                        }
                    }
                }
            }
        }
    }

    async fn handle_incoming_action(&mut self, action: Action) {
        if action.name == "cancel_action" {
            match serde_json::from_str::<Cancellation>(action.payload.as_str()) {
                Ok(payload) => {
                    self.try_route_action(payload.name.as_str(), action).await;
                }
                Err(_) => {
                    log::error!("Invalid cancel action payload: {:#?}", action.payload);
                    let _ = self.messages_tx.send_async(
                        ActionResponse::failure(action.action_id.as_str(), format!("Invalid cancel action payload: {:#?}", action.payload)).to_payload()
                    ).await;
                }
            }
        } else {
            self.try_route_action(action.name.as_str(), action.clone()).await;
        }
    }

    /// Handle received actions
    async fn try_route_action(&mut self, route_id: &str, action: Action) {
        match self.action_routes.get(route_id) {
            Some(route) => {
                if let Err(e) = route.try_send(action.clone()) {
                    log::error!("Could not forward action to collector: {e}");
                    let _ = self.messages_tx.send_async(
                        ActionResponse::failure(action.action_id.as_str(), format!("Could not forward action to collector: {e}")).to_payload()
                    ).await;
                }
            }
            None => {
                match &self.config.actions_callback {
                    Some(cb) => {
                        // forgive me for the harm I've caused this world
                        // none may atone for my actions but me
                        // and only in me shall the stain live on
                        // all I can be is sorry and that is all I am
                        cb(action);
                    }
                    None => {
                        let _ = self.messages_tx.send_async(
                            ActionResponse::failure(action.action_id.as_str(), format!("Uplink isn't configured to handle actions of type {route_id}")).to_payload()
                        ).await;
                    }
                }
            }
        }
    }
}
